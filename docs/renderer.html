<!DOCTYPE html>

<html>
<head>
  <title>renderer.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>renderer.js</h1>
        

        
          <div class="toc">
            <h3>Table of Contents</h3>
            <ol>
              
                
                <li>
                  <a class="source" href="control_panel.html">
                    control_panel.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_measure.html">
                    graphical_measure.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_note.html">
                    graphical_note.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_object.html">
                    graphical_object.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_state.html">
                    graphical_state.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_stave.html">
                    graphical_stave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="live_score.html">
                    live_score.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="measure.html">
                    measure.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="midi_player.html">
                    midi_player.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="music_constants.html">
                    music_constants.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="musical_state.html">
                    musical_state.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="note.html">
                    note.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="note_popup.html">
                    note_popup.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="playback_panel.html">
                    playback_panel.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="renderer.html">
                    renderer.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="score_editor.html">
                    score_editor.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="score_panel.html">
                    score_panel.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stave.html">
                    stave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="structs.html">
                    structs.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ui.html">
                    ui.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voice.html">
                    voice.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="z.html">
                    z.js
                  </a>
                </li>
              
            </ol>
          </div>
        
      </div>

      
        
        
        
          <div class='highlight'><pre>Vex = <span class="hljs-built_in">require</span>(<span class="hljs-string">"vexflow"</span>);
live_score = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./live_score.js"</span>);

<span class="hljs-comment">/**
* live_score.Renderer
*   converts the information in live_score.Musical_state into Vexflow objects
*   allowing the information to be displayed as a score
*/</span>


<span class="hljs-comment">/**
* Renderer
*   Constructor for the Renderer Object
* args
*   score_panel
*     the html canvas element on which the rendered score is displayed
* returns
*   none
*/</span>
live_score.Renderer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">score_panel</span>)</span>{

  <span class="hljs-comment">/**
  * the html canvas element on which the score is rendered
  */</span>
  <span class="hljs-keyword">this</span>.score_panel = score_panel;

  <span class="hljs-comment">/**
  * vexflow renderer, used to get the vexflow canvas context
  */</span>
  <span class="hljs-keyword">this</span>.vexflow_renderer = <span class="hljs-keyword">new</span> Vex.Flow.Renderer(score_panel,
    Vex.Flow.Renderer.Backends.CANVAS);

  <span class="hljs-comment">/**
  * vexflow renderer context, needed to render the score
  */</span>
  <span class="hljs-keyword">this</span>.score_panel_context = <span class="hljs-keyword">this</span>.vexflow_renderer.getContext();

  <span class="hljs-comment">/**
  * a list of the Vexflow staves created by the renderer
  */</span>
  <span class="hljs-keyword">this</span>.vexflow_staves = [];

  <span class="hljs-comment">/**
  * a list of lists. each index is a list of Vexflow voices belonging to the
  * corresponding Vexflow stave.
  */</span>
  <span class="hljs-keyword">this</span>.vexflow_voices_list = [];

  <span class="hljs-comment">/**
  * the current size of the score
  */</span>
  <span class="hljs-keyword">this</span>.stave_size = <span class="hljs-number">500</span>;
};

<span class="hljs-comment">/**
* clear_score
*   clears the contents of the canvas so it can be redrawn
* args
*   none
* returns
*   none
*/</span>
live_score.Renderer.prototype.clear_score = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">this</span>.score_panel_context.clearRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>.score_panel.width,
    <span class="hljs-keyword">this</span>.score_panel.height);
};

<span class="hljs-comment">/**
* resize_score
*   changes the size of the score
* args
*   stave_size
*     the new score size
* returns
*   none
*/</span>
live_score.Renderer.prototype.resize_score = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stave_size</span>)</span>{
  <span class="hljs-keyword">this</span>.stave_size = stave_size;
};

<span class="hljs-comment">/**
* display_score
*   takes the rendered vexflow staves and draws them on the canvas
* args
*   none
* returns
*   none
*/</span>
live_score.Renderer.prototype.display_score = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  
  <span class="hljs-keyword">this</span>.clear_score();

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.vexflow_staves.length; i++){
    <span class="hljs-keyword">var</span> vexflow_stave = <span class="hljs-keyword">this</span>.vexflow_staves[i];
    <span class="hljs-keyword">var</span> vexflow_voices = <span class="hljs-keyword">this</span>.vexflow_voices_list[i];
    
    vexflow_stave.draw();

    <span class="hljs-keyword">var</span> formatter = <span class="hljs-keyword">new</span> Vex.Flow.Formatter().joinVoices(vexflow_voices).
    format(vexflow_voices, <span class="hljs-keyword">this</span>.stave_size);

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; vexflow_voices.length; j++){
      vexflow_voices[j].draw(<span class="hljs-keyword">this</span>.score_panel_context,vexflow_stave);
    }
  }
};

<span class="hljs-comment">/**
* render_score
*   creates/renders the staves and voices of the score
* args
*   staves
*     an array of live_score.Stave passed in from the Musical_state object
* returns
*   none
*/</span>
live_score.Renderer.prototype.render_score = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">staves</span>)</span>{

  <span class="hljs-keyword">this</span>.vexflow_staves = [];
  <span class="hljs-keyword">this</span>.vexflow_voices_list = [];

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; staves.length; i++){
 
    <span class="hljs-keyword">var</span> vexflow_stave = <span class="hljs-keyword">new</span> Vex.Flow.Stave(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>.stave_size);
    vexflow_stave.addClef(staves[i].clef);

    <span class="hljs-keyword">var</span> vexflow_voices = <span class="hljs-keyword">this</span>.render_voices(staves[i].get_total_num_beats(),
      staves[i].voices);

    vexflow_stave.setContext(<span class="hljs-keyword">this</span>.score_panel_context);

    <span class="hljs-keyword">this</span>.vexflow_staves.push(vexflow_stave);
    <span class="hljs-keyword">this</span>.vexflow_voices_list.push(vexflow_voices);
  }
};

<span class="hljs-comment">/**
* render_voices
*   converts live_score voices into vexflow voices
* args
*   total_num_beats
*     the total number of beats in the entire score for one voice, used to
*     create the vexflow voice
*   voices
*     an array of the live_score voices
* returns
*   vexflow_voices
*     an array of formatted and aligned vexflow voices
*/</span>
live_score.Renderer.prototype.render_voices = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total_num_beats,voices</span>)</span>{

  <span class="hljs-keyword">var</span> vexflow_voices = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; voices.length; i++){
    <span class="hljs-keyword">var</span> vexflow_voice = <span class="hljs-keyword">this</span>.create_vexflow_voice(total_num_beats);
    <span class="hljs-keyword">var</span> vexflow_notes = <span class="hljs-keyword">this</span>.render_measures(voices[i].measures);
    vexflow_voice.addTickables(vexflow_notes);
    vexflow_voices.push(vexflow_voice);
  }
  <span class="hljs-keyword">return</span> vexflow_voices;
};

<span class="hljs-comment">/**
* render_measures
*   concats all notes for every measure into one array vexflow notes
* args
*   measures
*     an array of live_score measures
* returns
*   vexflow_notes
*     an array of all notes played in the score separated into measures by 
*     barlines
*/</span>
live_score.Renderer.prototype.render_measures = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">measures</span>)</span>{
  <span class="hljs-keyword">var</span> vexflow_notes = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; measures.length; i++){
    <span class="hljs-keyword">var</span> key = measures[i].key.toUpperCase();
    <span class="hljs-keyword">var</span> key_signature = live_score.keys[key]();
    vexflow_notes = vexflow_notes.concat(<span class="hljs-keyword">this</span>.render_notes(measures[i].notes,
      key_signature));
    vexflow_notes.push(<span class="hljs-keyword">new</span> Vex.Flow.BarNote());
  }
  <span class="hljs-keyword">return</span> vexflow_notes;
};

<span class="hljs-comment">/**
* render_notes
*   converts each measure's notes into arrays of vexflow notes
* args
*   notes
*     an array of live_score notes
*   key_signature
*     the key signature of the current measure
* returns
*   vexflow_notes
*     an array of all the notes played in a measure
*/</span>
live_score.Renderer.prototype.render_notes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">notes,key_signature</span>)</span>{
  <span class="hljs-keyword">var</span> vexflow_notes = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; notes.length; i++){
    vexflow_notes.push(<span class="hljs-keyword">this</span>.create_vexflow_note(notes[i],key_signature)); 
  }
  <span class="hljs-keyword">return</span> vexflow_notes;
};

<span class="hljs-comment">/**
* create_vex_flow_voice
*   does the actual conversion between a live_score voice and a vexflow voice
* args
*   total_num_beats
*     the total number of beats in the entire score
* returns
*   new Vex.Flow.Voice
*     vexflow voice with properties parallel to the live_score voice
*/</span>
live_score.Renderer.prototype.create_vexflow_voice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total_num_beats</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vex.Flow.Voice({
    num_beats: total_num_beats,
    beat_value: <span class="hljs-number">4</span>,
    resolution: Vex.Flow.RESOLUTION
  });
};

<span class="hljs-comment">/**
* create_vex_flow_note
*   does the actual conversion between a live_score note and a vexflow note
* args
*   note
*     live_score note
* returns
*   vexflow_note
*     vexflow note with properties parallel to the live_score note, with some
*     exceptions for notes that overlap notes.
*   key
*     the musical key of the measure containing the notes
*/</span>
live_score.Renderer.prototype.create_vexflow_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note,key</span>)</span>{
  <span class="hljs-keyword">var</span> length = note.length.toString();
  <span class="hljs-keyword">if</span>(note.type === live_score.rest_type){
    length += live_score.rest_type;
  }
  
  <span class="hljs-keyword">var</span> pitches = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; note.pitches.length; i++){
    pitches.push(note.pitches[i].pitch);
  }

  <span class="hljs-keyword">var</span> vexflow_note = <span class="hljs-keyword">new</span> Vex.Flow.StaveNote({keys:pitches,duration:length});
  
  <span class="hljs-keyword">if</span>(note.type === live_score.note_type){
    <span class="hljs-keyword">this</span>.add_accidentals(vexflow_note,key);
  }

  <span class="hljs-keyword">return</span> vexflow_note;
};

<span class="hljs-comment">/**
* add_accidentals
*   adds accidentals to notes before they are inserted into the score
* args
*   vexflow_note
*     the vexflow note object
*   key
*     the key signature of the current measure
* returns
*   none
*/</span>
live_score.Renderer.prototype.add_accidentals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">vexflow_note,key</span>)</span>{
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; vexflow_note.keyProps.length; i++){
    <span class="hljs-keyword">var</span> pitch = vexflow_note.keyProps[i].key;
    <span class="hljs-keyword">var</span> accidental = live_score.interpret_accidental(pitch,key);
    <span class="hljs-keyword">if</span>(accidental !== <span class="hljs-string">""</span>){
      vexflow_note.addAccidental(i,<span class="hljs-keyword">new</span> Vex.Flow.Accidental(accidental));
    }
  }
};

<span class="hljs-comment">/**
* get_staves
*   returns an array of vexflow staves
* args
*   none
* returns
*   this.vexflow_staves
*/</span>
live_score.Renderer.prototype.get_staves = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.vexflow_staves;
};

<span class="hljs-comment">/**
* get_voices
*   returns an array of arrays of Vexflow voices
* args
*   none
* returns
*   return this.vexflow_voices_list;
*/</span>
live_score.Renderer.prototype.get_voices = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.vexflow_voices_list;
};

<span class="hljs-built_in">module</span>.exports = live_score.Renderer;</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
