<!DOCTYPE html>

<html>
<head>
  <title>measure.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>measure.js</h1>
        

        
          <div class="toc">
            <h3>Table of Contents</h3>
            <ol>
              
                
                <li>
                  <a class="source" href="control_panel.html">
                    control_panel.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_measure.html">
                    graphical_measure.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_note.html">
                    graphical_note.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_object.html">
                    graphical_object.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_state.html">
                    graphical_state.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="graphical_stave.html">
                    graphical_stave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="live_score.html">
                    live_score.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="measure.html">
                    measure.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="midi_player.html">
                    midi_player.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="music_constants.html">
                    music_constants.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="musical_state.html">
                    musical_state.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="note.html">
                    note.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="note_popup.html">
                    note_popup.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="playback_panel.html">
                    playback_panel.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="renderer.html">
                    renderer.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="score_editor.html">
                    score_editor.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="score_panel.html">
                    score_panel.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="stave.html">
                    stave.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="structs.html">
                    structs.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="ui.html">
                    ui.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="voice.html">
                    voice.js
                  </a>
                </li>
              
                
                <li>
                  <a class="source" href="z.html">
                    z.js
                  </a>
                </li>
              
            </ol>
          </div>
        
      </div>

      
        
        
        
          <div class='highlight'><pre>live_score         = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./live_score.js"</span>);
live_score.structs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./structs.js"</span>);
live_score.Note    = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./note.js"</span>);

<span class="hljs-comment">/**
* Measure
*   The constructor for the Measure object.
* args
*   measure_meta_data
*     the measure_meta_data, described in structs.js, for this measure
* returns
*   none
*/</span>
live_score.Measure = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">measure_meta_data</span>)</span>{

  <span class="hljs-comment">/**
  * The key of this measure
  * <span class="hljs-doctag">TODO:</span> make this user settable
  */</span>
  <span class="hljs-keyword">this</span>.key = <span class="hljs-string">"C"</span>;

  <span class="hljs-comment">/**
  * the number of beats in the measure, can be thought of as the numerator of
  * the measure's time signature.
  */</span>
  <span class="hljs-keyword">this</span>.num_beats = measure_meta_data.num_beats;

  <span class="hljs-comment">/**
  * the length value of the beats in num_beats, can be thought of as the 
  * denominator of the measure's time signature
  */</span>
  <span class="hljs-keyword">this</span>.beat_value = measure_meta_data.beat_value;

  <span class="hljs-comment">/**
  * an array of live_score.Note objects, representing the notes that are played
  * in this measure
  */</span>
  <span class="hljs-keyword">this</span>.notes = [];

  <span class="hljs-comment">/**
  * a tick is used to determine rhythmic positioning of notes in a measure.
  * this determines the number of ticks in this measure, based on the time
  * signature
  */</span>
  <span class="hljs-keyword">this</span>.num_ticks = <span class="hljs-keyword">this</span>.num_beats * live_score.note_length_to_ticks(
    <span class="hljs-keyword">this</span>.beat_value);

  <span class="hljs-keyword">this</span>.create_empty_measure();
};

<span class="hljs-comment">/**
* create_empty_measure
*   Creates a measure whose length is based on measure_meta_data information,
*   and the measure is filled with rests
* args
*   none
* returns
*   none
*/</span>
live_score.Measure.prototype.create_empty_measure = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  
  <span class="hljs-keyword">var</span> rests = <span class="hljs-keyword">this</span>.fill_space_with_rests(<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>.num_ticks);
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rests.length; i++){
    <span class="hljs-keyword">this</span>.notes.push(rests[i]);
  }
};

<span class="hljs-comment">/**
* fill_space_with_rests
*   given a length of time in ticks, this fills that space with rests in 
*   such a way that makes musical sense
* args
*   start_tick
*     the starting position of the space that needs to be filled
*   end_tick
*     the ending position of the space that needs to be filled
* returns
*   rests
*     an array of rests that optimally fills the given space
*/</span>
live_score.Measure.prototype.fill_space_with_rests = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">start_tick,
  end_tick</span>)</span>{
  <span class="hljs-keyword">var</span> rests = [];
  <span class="hljs-keyword">var</span> ticks_so_far = start_tick;
  <span class="hljs-keyword">var</span> ticks_left = end_tick - start_tick;
  <span class="hljs-keyword">while</span>(ticks_left &gt; <span class="hljs-number">0</span>){
    <span class="hljs-keyword">var</span> beat_level = <span class="hljs-keyword">this</span>.calculate_beat_level(ticks_so_far);
    <span class="hljs-keyword">var</span> rest_length = <span class="hljs-keyword">this</span>.optimal_length(beat_level, ticks_left);
    ticks_left = ticks_left - live_score.note_length_to_ticks(rest_length);
    ticks_so_far += live_score.note_length_to_ticks(rest_length);
    rests.push(<span class="hljs-keyword">new</span> live_score.Note(live_score.rest_pitch,rest_length,
      live_score.rest_type));
  }
  <span class="hljs-keyword">return</span> rests;
};

<span class="hljs-comment">/**
* calculate_beat_level
*   given a number of ticks, determines the beat on which the that tick is
*   this makes sure that highest value note that can appear on a given beat
*   is the same as that beat. e.g. a quarter note would not appear on the
*   third sixteenth note beat of a measure.
* args
*   total_ticks
*     the position of the beat in the measure, in ticks
* returns
*   beat_level
*     the largest note/rest that can appear at the location denoted by
*     total_ticks
*/</span>
live_score.Measure.prototype.calculate_beat_level = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">total_ticks</span>)</span>{
  <span class="hljs-keyword">var</span> beat_level = <span class="hljs-keyword">this</span>.num_ticks;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> note_name <span class="hljs-keyword">in</span> live_score.note_lengths){
    <span class="hljs-keyword">var</span> note_length = live_score.note_lengths[note_name];
    <span class="hljs-keyword">var</span> ticks = live_score.note_length_to_ticks(note_length);
    <span class="hljs-keyword">if</span>(total_ticks % ticks === <span class="hljs-number">0</span> &amp;&amp;
       note_length &lt; beat_level  &amp;&amp;
       ticks &lt;= <span class="hljs-keyword">this</span>.num_ticks){
      beat_level = note_length; 
    }
  }
  <span class="hljs-keyword">return</span> beat_level;
};

<span class="hljs-comment">/**
* calculate_position_from_index
*   given a the index of an object measure's array, calculates the tick
*   position of that object
* args
*   index
*     the index of the object in this.notes;
* returns
*   position
*     the position, in ticks, of the object
*/</span>
live_score.Measure.prototype.calculate_position_from_index = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>)</span>{
  <span class="hljs-keyword">var</span> position = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; index; i++){
    position += live_score.note_length_to_ticks(<span class="hljs-keyword">this</span>.notes[i].length);
  }
  <span class="hljs-keyword">return</span> position;
};

<span class="hljs-comment">/**
* optimal_length
*   given the largest possible length that can appear and the length of the
*   empty space, determines the largest note length that can be inserted
* args
*   beat_position
*     the size of the largest possible rest that can be placed
*   num_ticks
*     the length of the space that needs to be filled
* returns
*   best_fit_note
*     the largest note length that is both within the bounds of the 
*     beat_position and whose length is not larger than num_ticks
*/</span>
live_score.Measure.prototype.optimal_length = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">beat_position,num_ticks</span>)</span>{

  <span class="hljs-keyword">var</span> min_tick_difference = <span class="hljs-keyword">this</span>.num_ticks;
  <span class="hljs-keyword">var</span> best_fit_note = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> note_name <span class="hljs-keyword">in</span> live_score.note_lengths){
    <span class="hljs-keyword">var</span> note_length = live_score.note_lengths[note_name];
    <span class="hljs-keyword">var</span> note_ticks = live_score.note_length_to_ticks(note_length);
    <span class="hljs-keyword">var</span> tick_difference = num_ticks - note_ticks;
    <span class="hljs-keyword">if</span>(note_length &gt;= beat_position &amp;&amp; 
      tick_difference &lt; min_tick_difference &amp;&amp;
      tick_difference &gt;= <span class="hljs-number">0</span>){
      
      min_tick_difference = tick_difference;
      best_fit_note = note_length;
    }
  }
  <span class="hljs-keyword">return</span> best_fit_note;
};

<span class="hljs-comment">/**
* add_note
*   adds a note to the measure
* args
*   note_info
*     a struct (see structs.js) that contiains information about the
*     note being inserted
* returns
*   a boolean of whether or not the note was inserted successfully 
*/</span>
live_score.Measure.prototype.add_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_info</span>)</span>{
  note_info.quantized_tick_position = <span class="hljs-keyword">this</span>.quantize_position(
    note_info.quantization,note_info.tick_position);

  note_info.beat_level = <span class="hljs-keyword">this</span>.calculate_beat_level(
    note_info.quantized_tick_position);

  <span class="hljs-keyword">this</span>.place_note_in_measure(note_info);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-comment">/**
* remove_note
*   removes a note from the measure
* args
*   note_info
*     a struct (see structs.js) that contiains information about the
*     note being removed
* returns
*   a boolean of whether or not the note was removed successfully 
*/</span>
live_score.Measure.prototype.remove_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_info</span>)</span>{
  <span class="hljs-keyword">this</span>.remove_note_from_measure(note_info);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};

<span class="hljs-comment">/**
* quantize_position
*   determines the quantized position, in ticks, of a note
* args
*   quantization
*     the beat level to which the note is being quantized
*   position
*     the position of a note in the measure represented as a percentage
* returns
*   quantized_ticks_position
*     the quantized position of the note, in ticks
*/</span>
live_score.Measure.prototype.quantize_position = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">quantization,
  tick_position</span>)</span>{
  
  <span class="hljs-keyword">var</span> quantized_beat_ticks = live_score.note_length_to_ticks(quantization);
  <span class="hljs-keyword">var</span> num_quantized_beats = <span class="hljs-keyword">this</span>.num_ticks/quantized_beat_ticks;</pre></div>
        
      
        
        <p>var position_in_ticks = position*this.num_ticks;</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">var</span> quantized_tick_position;
  <span class="hljs-keyword">var</span> min_tick_difference;

  <span class="hljs-keyword">if</span>(num_quantized_beats * quantized_beat_ticks &lt; <span class="hljs-keyword">this</span>.num_ticks){
    quantized_tick_position = num_quantized_beats * quantized_beat_ticks;
    min_tick_difference = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-keyword">this</span>.num_ticks - tick_position);
  }<span class="hljs-keyword">else</span>{
    quantized_tick_position = <span class="hljs-number">0</span>;
    min_tick_difference = <span class="hljs-keyword">this</span>.num_ticks;
  }
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num_quantized_beats; i++){
    <span class="hljs-keyword">var</span> ticks_before_beat = i * quantized_beat_ticks;
    <span class="hljs-keyword">var</span> tick_difference = <span class="hljs-built_in">Math</span>.abs(ticks_before_beat - tick_position);
    <span class="hljs-keyword">if</span>(tick_difference &lt; min_tick_difference){
      min_tick_difference = tick_difference;
      quantized_ticks_position = ticks_before_beat;
    }
  }
  <span class="hljs-keyword">return</span> quantized_ticks_position;
};

<span class="hljs-comment">/**
* place_note_in_measure
*   handles all the different cases of how a note can be inserted into 
*   a measure
* args
*   note_info
*     a struct, described in structs.js, with information about the note being
*     inserted
* returns
*   none
*/</span>
live_score.Measure.prototype.place_note_in_measure = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_info</span>)</span>{
  <span class="hljs-keyword">var</span> note_position = note_info.quantized_tick_position;
  <span class="hljs-keyword">var</span> current_position = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> note_added = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">this</span>.notes.length &amp;&amp; !note_added; i++){
    <span class="hljs-keyword">if</span>(current_position === note_position &amp;&amp; <span class="hljs-keyword">this</span>.notes[i].is_note()){
      <span class="hljs-keyword">this</span>.notes[i].add_note(note_info);
      note_added = <span class="hljs-literal">true</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_position &gt; note_position &amp;&amp; <span class="hljs-keyword">this</span>.notes[i<span class="hljs-number">-1</span>].is_note()){
      <span class="hljs-keyword">this</span>.shorten_previous_and_insert_note(note_position,current_position,i<span class="hljs-number">-1</span>,
        note_info);
      note_added = <span class="hljs-literal">true</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_position &gt; note_position &amp;&amp; <span class="hljs-keyword">this</span>.notes[i<span class="hljs-number">-1</span>].is_rest()){
      <span class="hljs-keyword">this</span>.split_rest_and_insert_note(note_position,current_position,i<span class="hljs-number">-1</span>,
        note_info);
      note_added = <span class="hljs-literal">true</span>;
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_position === note_position &amp;&amp; <span class="hljs-keyword">this</span>.notes[i].is_rest()){
      <span class="hljs-keyword">this</span>.remove_rest_and_insert_note(note_position,current_position,i,
        note_info);
      note_added = <span class="hljs-literal">true</span>;
    }<span class="hljs-keyword">else</span>{
      <span class="hljs-keyword">var</span> note_length = <span class="hljs-keyword">this</span>.notes[i].length;
      <span class="hljs-keyword">var</span> tick_length = live_score.note_length_to_ticks(note_length);
      current_position += tick_length;
    }
  }
};

<span class="hljs-comment">/**
* space_after_note
*   determines the amount of space a note can take up without overlapping with
*   the next note in the measure
* args
*   note_position
*     the position of the note being inserted (in ticks)
*   current_position
*     the position of the position counter used in place_note_in_measure.
*     denotes the end point (in ticks) of the current note
* returns
*   space_after_note
*     the amount of space (in ticks) after the starting position of the note
*/</span>
live_score.Measure.prototype.space_after_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_position,
  current_position,current_index</span>)</span>{

  <span class="hljs-keyword">var</span> note_found = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> space_after_note = current_position - note_position;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = current_index; i &lt; <span class="hljs-keyword">this</span>.notes.length &amp;&amp; !note_found; i++){
    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.notes[i].is_note()){
      space_after_note += live_score.note_length_to_ticks(
        <span class="hljs-keyword">this</span>.notes[i].length);
    }<span class="hljs-keyword">else</span>{
      note_found = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">return</span> space_after_note;
};

<span class="hljs-comment">/**
* calculate_display_length
*   determines the size the note will be rendered as, this is based on the 
*   length of the note, the position of the note in the measure, and how close
*   it is to other notes. 
* args
*   note_info
*     a struct (see structs.js) with information about the note being inserted
* returns
*   display_length
*     the maximum length that the note can be without violating any constraints.
*     including: 
*       the note's length being longer than the beat_level
*       the note not overlapping with the following note
*       the note not exceeding its length
*/</span>
live_score.Measure.prototype.calculate_display_length = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_info</span>)</span>{
 
  <span class="hljs-keyword">var</span> beat_level = note_info.beat_level;
  <span class="hljs-keyword">var</span> length = note_info.note_length;
  <span class="hljs-keyword">var</span> max_length = <span class="hljs-keyword">this</span>.optimal_length(beat_level,note_info.max_length);
  <span class="hljs-keyword">var</span> display_length = length;
  
  <span class="hljs-keyword">if</span>(live_score.note_length_greater_than(length,max_length)){
    display_length = max_length;
  }
  <span class="hljs-keyword">if</span>(live_score.note_length_greater_than(max_length,beat_level)){
    display_length = beat_level;
  }
  <span class="hljs-keyword">return</span> display_length;
};

<span class="hljs-comment">/**
* shorten_previous_and_insert_note
*   inserts a note into the measure in the case where the note being inserted
*   overlaps with a note already in the meausre. The previous note is shortened
*   to make room for the new note, the new note is inserted, and any extra
*   space is filled with rests
* args
*   note_position
*     the position of the note being inserted (in ticks)
*   current_position
*     the position of the position counter used in place_note_in_measure.
*     denotes the end point (in ticks) of the current note
*   note_to_split_index
*     the index, in the notes array, of the note that is being split to make
*     room for the new note.
*   note_info
*     a struct (see structs.js) with information about the note being inserted   
* returns
*   none
*/</span>
live_score.Measure.prototype.shorten_previous_and_insert_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  note_position,current_position,note_to_split_index,note_info</span>)</span>{

  <span class="hljs-keyword">var</span> shortened_note_info = <span class="hljs-keyword">this</span>.recalculate_note_info(note_position,
    current_position,note_to_split_index,note_info);

  note_info.max_length = <span class="hljs-keyword">this</span>.space_after_note(note_position,current_position,
    note_to_split_index + <span class="hljs-number">1</span>);
  note_info.display_length = <span class="hljs-keyword">this</span>.calculate_display_length(note_info);

  <span class="hljs-keyword">var</span> shortened_note = <span class="hljs-keyword">this</span>.remove_from_measure(note_to_split_index);

  <span class="hljs-keyword">this</span>.insert_rests_after_note(current_position,note_to_split_index,note_info);
  <span class="hljs-keyword">this</span>.insert_new_note(note_to_split_index,note_info);
  <span class="hljs-keyword">this</span>.insert_rests_between_shortened_note_and_new_note(note_position,
    current_position,note_to_split_index,shortened_note,shortened_note_info);
  <span class="hljs-keyword">this</span>.insert_shortened_note(shortened_note_info,shortened_note,
    note_to_split_index);
};

<span class="hljs-comment">/**
* recalculate_note_info
*   recreates the note_info struct of a note that has already been inserted
*   in order to allow that note to be processed like a new note.
* args
*   note_position
*     the position of the note being inserted (in ticks)
*   current_position
*     the position of the position counter used in place_note_in_measure.
*     denotes the end point (in ticks) of the current note
*   note_to_split_index
*     the index, in the notes array, of the note that is being split to make
*     room for the new note.
*   note_info
*     a struct (see structs.js) with information about the note being inserted   
* returns
*   old_note_info
*     a new note_info struct with information about a note that has already
*     been inserted into the measure
*/</span>
live_score.Measure.prototype.recalculate_note_info = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_position,
    current_position,note_to_split_index,note_info</span>)</span>{

  <span class="hljs-keyword">var</span> old_note_info = live_score.structs.create_note_info(); 
  <span class="hljs-keyword">var</span> old_note_length_in_ticks = live_score.note_length_to_ticks(
    <span class="hljs-keyword">this</span>.notes[note_to_split_index].length);
  <span class="hljs-keyword">var</span> start_of_old_note = current_position - old_note_length_in_ticks;

  old_note_info.beat_level = <span class="hljs-keyword">this</span>.calculate_beat_level(start_of_old_note);
  old_note_info.max_length = note_position - start_of_old_note;
  old_note_info.display_length = <span class="hljs-keyword">this</span>.calculate_display_length(
    old_note_info);

  <span class="hljs-keyword">return</span> old_note_info;
};

<span class="hljs-comment">/**
* insert_rests_between_shortened_note_and_new_note
*   finds the end of the shortened note, and the beginning of the new note
*   and fills the space remaining between them with rests.
* args
*   note_position
*     the position of the note being inserted (in ticks)
*   current_position
*     the position of the position counter used in place_note_in_measure.
*     denotes the end point (in ticks) of the current note
*   note_to_split_index
*     the index, in the notes array, of the note that is being split to make
*     room for the new note.
*   shortened_note
*     the note whose length has been shortened to make room for the new note
*   shortened_note_info
*     a note_info struct (see structs.js) with information about the shortened
*     note
* returns
*   none
*/</span>
live_score.Measure.prototype.insert_rests_between_shortened_note_and_new_note =
  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_position,current_position,note_to_split_index,shortened_note,
  shortened_note_info</span>)</span>{
 
  <span class="hljs-keyword">var</span> start_of_shortened_note = current_position - 
    live_score.note_length_to_ticks(shortened_note.length);
  <span class="hljs-keyword">var</span> length_of_shortened_note = live_score.note_length_to_ticks(
    shortened_note_info.display_length);
  <span class="hljs-keyword">var</span> end_of_shortened_note = start_of_shortened_note + 
    length_of_shortened_note; 
  
  <span class="hljs-keyword">var</span> length_of_new_note = current_position - note_position;
  <span class="hljs-keyword">var</span> start_of_new_note = current_position - length_of_new_note;

  <span class="hljs-keyword">var</span> start_position = end_of_shortened_note;
  <span class="hljs-keyword">var</span> end_position = start_of_new_note;

  <span class="hljs-keyword">var</span> rests = <span class="hljs-keyword">this</span>.fill_space_with_rests(start_position,end_position);
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = rests.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
    <span class="hljs-keyword">this</span>.notes.splice(note_to_split_index,<span class="hljs-number">0</span>,rests[i]);
  }
};

<span class="hljs-comment">/**
* insert_shortened_note
*   places the note the note that has been shortened to make room for the
*   new note back into the measure
* args
*   shortened_note_info
*     a note_info struct (see structs.js) with information about the shortened
*     note
*   shortened_note
*     the note whose length has been shortened to make room for the new note
*   index
*     the position in the notes array where the note is to be inserted
* returns
*   none
*/</span>
live_score.Measure.prototype.insert_shortened_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  shortened_note_info,shortened_note,index</span>)</span>{
  shortened_note.length = shortened_note_info.display_length;
  <span class="hljs-keyword">this</span>.notes.splice(index,<span class="hljs-number">0</span>,shortened_note);
};

<span class="hljs-comment">/**
* remove_rest_and_insert_note
*   handles the insert case where a note is placed where a rest currently is
* args
*   current_position
*     the position of the rest that is being removed
*   note_to_split_index
*     the index of the rest that is being removed
*   note_info
*     a struct, described in structs.js, with information about the note being
*     inserted
* returns
*   none
*/</span>
live_score.Measure.prototype.remove_rest_and_insert_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  note_position,current_position,note_to_split_index,note_info</span>)</span>{
  
  note_info.max_length = <span class="hljs-keyword">this</span>.space_after_note(note_position,current_position,
    note_to_split_index);
  note_info.display_length = <span class="hljs-keyword">this</span>.calculate_display_length(note_info);

  <span class="hljs-keyword">var</span> note_to_split = <span class="hljs-keyword">this</span>.remove_from_measure(note_to_split_index);
  <span class="hljs-keyword">var</span> end_of_rest = current_position + live_score.note_length_to_ticks(
    note_to_split.length);
  <span class="hljs-keyword">this</span>.insert_rests_after_note(end_of_rest,note_to_split_index,note_info);
  <span class="hljs-keyword">this</span>.insert_new_note(note_to_split_index,note_info);
};

<span class="hljs-comment">/**
* split_rest_and_insert_note
*   handles the insert case where a note is placed in the middle of a rest
* args
*   current_position
*     the end position of the rest being split
*   note_to_split_index
*     the index of the rest that is being split
*   note_info
*     a struct, described in structs.js, with information about the note being
*     inserted
* returns
*   none
*/</span>
live_score.Measure.prototype.split_rest_and_insert_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  note_position,current_position,note_to_split_index,note_info</span>)</span>{
   
  note_info.max_length = <span class="hljs-keyword">this</span>.space_after_note(note_position,current_position,
    note_to_split_index + <span class="hljs-number">1</span>);    
  note_info.display_length = <span class="hljs-keyword">this</span>.calculate_display_length(note_info);

  <span class="hljs-keyword">var</span> note_to_split = <span class="hljs-keyword">this</span>.remove_from_measure(note_to_split_index);
  <span class="hljs-keyword">this</span>.insert_rests_after_note(current_position,note_to_split_index,note_info);
  <span class="hljs-keyword">this</span>.insert_new_note(note_to_split_index,note_info);
  <span class="hljs-keyword">this</span>.insert_rests_before_note(current_position,note_to_split_index,note_to_split,
    note_info); 
};

<span class="hljs-comment">/**
* remove_from_measure
*   removes a note or rest at a given position
* args
*   rest_index
*     the index of the note/rest that is being removed
* returns
*   rest_to_remove
*     the note/rest that has been removed 
*/</span>
live_score.Measure.prototype.remove_from_measure = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>)</span>{
  <span class="hljs-keyword">var</span> object_to_remove = <span class="hljs-keyword">this</span>.notes[index];
  <span class="hljs-keyword">this</span>.notes.splice(index,<span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> object_to_remove;
};

<span class="hljs-comment">/**
* insert_rests_before_note
*   in the case where an inserted note splits a rest, determine how to fill
*   the empty space before the note
* args
*   current_position
*     the end position of the rest being split
*   note_to_split_index
*     the index of the rest that is being split
*   note_to_split
*     the rest that is being split
*   note_info
*     a struct, described in structs.js, with information about the note being
*     inserted
* returns
*   none
*/</span>
live_score.Measure.prototype.insert_rests_before_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  current_position,note_to_split_index,note_to_split,note_info</span>)</span>{
  
  <span class="hljs-keyword">var</span> start_position = current_position - live_score.note_length_to_ticks(
    note_to_split.length);
  <span class="hljs-keyword">var</span> end_position = note_info.quantized_tick_position; 

  <span class="hljs-keyword">var</span> rests = <span class="hljs-keyword">this</span>.fill_space_with_rests(start_position,
    end_position);
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = rests.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
    <span class="hljs-keyword">this</span>.notes.splice(note_to_split_index,<span class="hljs-number">0</span>,rests[i]);
  }
};

<span class="hljs-comment">/**
* insert_rests_after_note
*   in the case where an inserted note splits a rest, determine how to fill
*   the empty space after the note
* args
*   current_position
*     the end position of the rest being split
*   note_to_split_index
*     the index of the rest that is being split
*   note_info
*     a struct, described in structs.js, with information about the note being
*     inserted
* returns
*   none
*/</span>
live_score.Measure.prototype.insert_rests_after_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  current_position,note_to_split_index,note_info</span>)</span>{
 
  <span class="hljs-keyword">var</span> start_position = note_info.quantized_tick_position + 
    live_score.note_length_to_ticks(note_info.display_length);
  <span class="hljs-keyword">var</span> end_position = current_position;

  <span class="hljs-keyword">var</span> rests = <span class="hljs-keyword">this</span>.fill_space_with_rests(start_position,
    end_position);
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = rests.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
    <span class="hljs-keyword">this</span>.notes.splice(note_to_split_index,<span class="hljs-number">0</span>,rests[i]);
  }
};

<span class="hljs-comment">/**
* insert_new_note
*   insert a new note into the measure
* args
*   note_to_split_index
*     the index where the note is being inserted
*   note_info
*     a struct, described in structs.js, with information about the note being
*     inserted
* returns
*   none
*/</span>
live_score.Measure.prototype.insert_new_note = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_to_split_index,
  note_info</span>)</span>{

  <span class="hljs-keyword">var</span> pitch = live_score.translate_midi_number_to_pitch(note_info.pitch);
  <span class="hljs-keyword">var</span> new_note = <span class="hljs-keyword">new</span> live_score.Note(pitch, note_info.note_length,
    live_score.note_type, note_info.display_length);
  <span class="hljs-keyword">this</span>.notes.splice(note_to_split_index,<span class="hljs-number">0</span>,new_note);
};

<span class="hljs-comment">/**
* remove_note_from_measure
*   removes a note from the measure
* args
*   note_info
*     a struct (see structs.js) that contiains information about the
*     note being removed
* returns
*   none
*/</span>
live_score.Measure.prototype.remove_note_from_measure = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">note_info</span>)</span>{
  <span class="hljs-keyword">var</span> note_position = note_info.quantized_tick_position;
  <span class="hljs-keyword">var</span> current_position = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> note_removed = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> empty_note;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">this</span>.notes.length &amp;&amp; !note_removed; i++){
    <span class="hljs-keyword">if</span>(current_position === note_position &amp;&amp; <span class="hljs-keyword">this</span>.notes[i].is_note()){
      empty_note = <span class="hljs-keyword">this</span>.notes[i].remove_note(note_info);
      note_removed = <span class="hljs-literal">true</span>;
    }<span class="hljs-keyword">else</span>{
      <span class="hljs-keyword">var</span> note_length = <span class="hljs-keyword">this</span>.notes[i].length;
      <span class="hljs-keyword">var</span> tick_length = live_score.note_length_to_ticks(note_length);
      current_position += tick_length;
    }
  }
  <span class="hljs-keyword">if</span>(empty_note){
    <span class="hljs-keyword">var</span> note_index = i<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">this</span>.notes[note_index].make_rest();
    <span class="hljs-keyword">this</span>.merge_rests(note_index);
  }
};

<span class="hljs-comment">/**
* merge_rests
*   attempts to merge smaller rests together after a note has been removed
* args
*   rest_index
*     the index of the rest that has replaced the removed note
* returns
*   none
*/</span>
live_score.Measure.prototype.merge_rests = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rest_index</span>)</span>{
  
  <span class="hljs-keyword">var</span> first_rest_index = <span class="hljs-keyword">this</span>.find_start_of_rest_sequence(rest_index);
  <span class="hljs-keyword">var</span> last_rest_index = <span class="hljs-keyword">this</span>.find_end_of_rest_sequence(rest_index);
  <span class="hljs-keyword">var</span> start_tick = <span class="hljs-keyword">this</span>.calculate_position_from_index(first_rest_index);

  <span class="hljs-keyword">var</span> end_tick = <span class="hljs-keyword">this</span>.calculate_position_from_index(last_rest_index) +
    live_score.note_length_to_ticks(<span class="hljs-keyword">this</span>.notes[last_rest_index].length);

  <span class="hljs-keyword">var</span> rests = <span class="hljs-keyword">this</span>.fill_space_with_rests(start_tick,end_tick);

  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(i = first_rest_index; i &lt;= last_rest_index; i++){
    <span class="hljs-keyword">this</span>.notes.splice(first_rest_index,<span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">for</span>(i = rests.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
    <span class="hljs-keyword">this</span>.notes.splice(first_rest_index,<span class="hljs-number">0</span>,rests[i]);
  }
};

<span class="hljs-comment">/**
* find_start_of_rest_sequence
*   find the first position of rests that can potentially be merged into a 
*   single longer rest
* args
*   rest_index
*     the index of the rest that has replaced the removed note
* returns
*   first_rest_index
*     the first rest in the series of rests that can be merged
*/</span>
live_score.Measure.prototype.find_start_of_rest_sequence = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">
  rest_index</span>)</span>{
  
  <span class="hljs-keyword">var</span> note_found = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> first_rest_index = rest_index;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = rest_index; i &gt;= <span class="hljs-number">0</span> &amp;&amp; !note_found; i--){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.notes[i].is_rest()){
      first_rest_index = i;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.notes[i].is_note()){
      note_found = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">return</span> first_rest_index;
};

<span class="hljs-comment">/**
* find_end_of_rest_sequence
*   find the last position of rests that can potentially be merged into a 
*   single longer rest
* args
*   rest_index
*     the index of the rest that has replaced the removed note
* returns
*   last_rest_index
*     the last rest in the series of rests that can be merged
*/</span>
live_score.Measure.prototype.find_end_of_rest_sequence = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rest_index</span>)</span>{
  
  <span class="hljs-keyword">var</span> note_found = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> last_rest_index = rest_index;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = rest_index; i &lt; <span class="hljs-keyword">this</span>.notes.length &amp;&amp; !note_found; i++){
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.notes[i].is_rest()){
      last_rest_index = i;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.notes[i].is_note()){
      note_found = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">return</span> last_rest_index;
};

<span class="hljs-comment">/**
* get_notes_array
*   gets an array of all the note objects in this measure, used for playing
*   midi 
* args
*   none
* returns
*   notes
*     an array of all the note objects in this measure
*/</span>
live_score.Measure.prototype.get_notes_array = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> notes = [];
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.notes.length; i++){
    notes.push(<span class="hljs-keyword">this</span>.notes[i].get_pitches());
  }
  <span class="hljs-keyword">return</span> notes;
};

<span class="hljs-built_in">module</span>.exports = live_score.Measure;</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
